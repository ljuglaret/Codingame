import System.IO
import Control.Monad

main :: IO ()
main = do
    hSetBuffering stdout NoBuffering -- DO NOT REMOVE
    
    -- Auto-generated code below aims at helping you parse
    -- the standard input according to the problem statement.
    
    input_line <- getLine
    let n = read input_line :: Int
    message <- getLine
    
    -- hPutStrLn stderr "Debug messages..."
    
    -- Write answer to stdout
    putStrLn (affichage n message)
    return ()
    
  
affichage x s = 
    if (x < 0)
    then iterateEncoding x s 
    else iterateDecoding x s
  
sommeFacto x = 
    if x == 0
    then 0 
    else x + (sommeFacto (x - 1))

trouveTaille l  = 
    let 
        aux i = 
            if (sommeFacto i > length l)
            then i - 1 
            else aux  (i+1)
    in aux 0 

-- encoding

sens1 l = 
    let
        aux   concate l0 i  = 
            let 
                gauche = take i  l0 
                droite = drop i l0 
            in
                if (length l0 == 0)
                then concate 
                else
                    if (i `mod`2 ==0)
                    then aux   (gauche ++ concate)  droite (i+1)
                    else aux   ( concate ++ gauche )  droite (i+1) 
    in aux  "" l 1



iterateEncoding x l = 
    let 
        y = abs x 
    in
        if (y == 0)
        then l
        else iterateEncoding (y - 1) (sens1 l) 

prendreEnTete x s = take x  s
enleverEnTete x s =  drop  x s 

prendreEnQueue x s = reverse(prendreEnTete x(reverse s) ) 
enleverEnQueue x s =reverse(enleverEnTete x (reverse s)  )



--decoding (positive)

sens2 l =  
    let
        aux   concate l0 i j  =
            if (i == 0)
            then concate 
            else 
                if ( j `mod` 2  /= 0)
                then aux ((prendreEnTete i l0)++concate) (enleverEnTete i l0) (i - 1)(j + 1)
                else  aux ((prendreEnQueue i l0)++concate) (enleverEnQueue i l0) (i - 1)(j + 1)
    in
        let 
            tailleDepart =  (sommeFacto (trouveTaille l))
            initial = 
                if ( (trouveTaille l) `mod` 2 == 0)
                then 1
                else 0
        in aux "" (choix1 l ) (trouveTaille l)  initial

choix1 l = 
    if ( (trouveTaille l) `mod` 2 == 0)
    then (prendreEnTete  (sommeFacto (trouveTaille l)) l )
    else (prendreEnQueue  (sommeFacto (trouveTaille l)) l )

choix2 l = 
    if ( (trouveTaille l) `mod` 2 == 0)
    then prendreEnQueue ((length l) - (sommeFacto (trouveTaille l)))l
    else  prendreEnTete ((length l) - (sommeFacto (trouveTaille l)))l


sens2b l = (sens2 l) ++ (choix2 l)
           
iterateDecoding x l =
        if (x == 0)
        then l 
        else iterateDecoding (x - 1) (sens2b l) 

