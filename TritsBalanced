import System.IO
import Control.Monad
import Data.Bits(shiftL, shiftR)

main :: IO ()
main = do
    hSetBuffering stdout NoBuffering -- DO NOT REMOVE
    
    -- Auto-generated code below aims at helping you parse
    -- the standard input according to the problem statement.
    
    lhs <- getLine
    op <- getLine
    rhs <- getLine
    
    -- hPutStrLn stderr "Debug messages..."
    
    -- Write answer to stdout
    putStrLn (operations op lhs rhs)
    return ()


type  Base =  Int 

baseTer  :: Char -> Int 
baseTer c = 
    if (c=='T') 
    then -1
    else
        if (c == '0')
        then 0 
        else 1 


transforme :: String -> [Int]
transforme s = reverse(map(\elt -> baseTer elt) s)
   

depuisBaseTer :: String ->Int
depuisBaseTer s = 
    let 
        t :: [Int]
        t = transforme s
    in foldr(fct 3 ) 0 t

fct :: Base -> Int -> Int -> Int
fct base x y = x + base*y


versBaseTer :: Int -> String 
versBaseTer x = 
    let
        aux acc x0 = 
            if (x0 == 0)
            then concat (map(\elt -> if (elt == -1) then "T" else show elt) acc)
            else
                if ((x0 `mod` 3) == 2)
                then aux (((x0 `mod` 3)-3):acc)  ((x0 +1 )`div` 3)
                else aux (((x0 `mod` 3)):acc)  ((x0 `div` 3))
                
    in aux [] x

ajouteZero ::  Int -> String 
ajouteZero  x = 
    if (x == 0) 
    then ""
    else "0"++(ajouteZero (x - 1 ))
    

operations::String ->  String -> String -> String 
operations ope s1 s2 =
    case ope of 
        "+"-> versBaseTer ((depuisBaseTer s1) + (depuisBaseTer s2))
        "-"-> versBaseTer ((depuisBaseTer s1) - (depuisBaseTer s2))
        "*"-> versBaseTer ((depuisBaseTer s1) * (depuisBaseTer s2))
        "<<" -> s1 ++ (ajouteZero  (depuisBaseTer s2))
        ">>" ->
            if(length s1 < (depuisBaseTer s2))
            then "0"
            else take (length s1 -  (depuisBaseTer s2) )s1   
        
        _ -> "nn"


